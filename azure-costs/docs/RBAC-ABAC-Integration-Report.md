# Azure Costs RBAC/ABAC Integration Report

## Executive Summary

The Azure Costs API service is currently experiencing authentication failures (403 Forbidden) on protected endpoints despite having valid JWT tokens. This report analyzes the root causes and outlines the required steps to properly integrate the service with the VF Services RBAC/ABAC system.

## Current State Analysis

### What's Working
- ✅ JWT middleware is installed and configured
- ✅ JWT tokens are being generated by the identity provider
- ✅ Basic authentication flow is set up
- ✅ Redis connection is established
- ✅ Service can communicate with identity provider

### What's Failing
- ❌ Service is not registered with the identity provider
- ❌ No service manifest defined
- ❌ No RBAC roles or attributes configured
- ❌ Missing ABAC policies
- ❌ User attributes cannot be fetched (404 error)
- ❌ No app configuration for auto-registration

## Root Cause Analysis

The primary issue is that Azure Costs service is not properly registered with the identity provider's RBAC/ABAC system. When a request comes in:

1. JWT middleware validates the token ✓
2. Middleware attempts to load user attributes from Redis
3. Redis cache miss occurs (expected for first request)
4. System tries to refresh from identity provider at `/api/refresh-user-cache/`
5. **Identity provider returns 404** because it doesn't recognize "azure_costs" as a registered service
6. Without user attributes, the authentication fails with 403 Forbidden

## Required Implementation Steps

### 1. Create Service Manifest (`azure_costs/manifest.py`)

```python
SERVICE_MANIFEST = {
    "service": "azure_costs",
    "display_name": "Azure Costs Management",
    "description": "Service for tracking and managing Azure cloud costs",
    "manifest_version": "1.0",
    "roles": [
        {
            "name": "costs_viewer",
            "display_name": "Costs Viewer",
            "description": "Can view Azure costs and reports",
            "is_global": False
        },
        {
            "name": "costs_manager",
            "display_name": "Costs Manager",
            "description": "Can manage budgets and cost allocations",
            "is_global": False
        },
        {
            "name": "costs_admin",
            "display_name": "Costs Administrator",
            "description": "Full access to all cost management features",
            "is_global": True
        }
    ],
    "attributes": [
        {
            "name": "azure_subscription_ids",
            "display_name": "Azure Subscription IDs",
            "description": "List of Azure subscription IDs the user can access",
            "type": "list_string",
            "is_required": False,
            "default_value": []
        },
        {
            "name": "cost_center_ids",
            "display_name": "Cost Center IDs",
            "description": "List of cost centers the user can view",
            "type": "list_string",
            "is_required": False,
            "default_value": []
        },
        {
            "name": "budget_limit",
            "display_name": "Budget Limit",
            "description": "Maximum budget the user can allocate",
            "type": "integer",
            "is_required": False,
            "default_value": 0
        },
        {
            "name": "can_export_reports",
            "display_name": "Can Export Reports",
            "description": "Whether user can export cost reports",
            "type": "boolean",
            "is_required": False,
            "default_value": False
        }
    ]
}
```

### 2. Update App Configuration (`azure_costs/apps.py`)

```python
from django.apps import AppConfig
import logging
import requests
from django.conf import settings

logger = logging.getLogger(__name__)

class AzureCostsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'azure_costs'

    def ready(self):
        # Import signal handlers if any
        # from . import signals
        
        # Import policies
        from . import policies
        
        # Register service manifest with identity provider
        self._register_manifest()
    
    def _register_manifest(self):
        """Register service manifest with identity provider."""
        try:
            from .manifest import SERVICE_MANIFEST
            
            identity_provider_url = getattr(settings, 'IDENTITY_PROVIDER_URL', 'http://identity-provider:8000')
            register_url = f"{identity_provider_url}/api/services/register/"
            
            logger.info(f"Registering service manifest with identity provider at {register_url}")
            
            response = requests.post(
                register_url,
                json=SERVICE_MANIFEST,
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info("Service manifest registered successfully")
            else:
                logger.error(f"Failed to register service manifest: {response.status_code} - {response.text}")
        
        except ImportError:
            logger.warning("No service manifest found - skipping registration")
        except requests.exceptions.RequestException as e:
            logger.error(f"Error registering service manifest: {e}")
        except Exception as e:
            logger.error(f"Unexpected error during manifest registration: {e}")
```

### 3. Create ABAC Policies (`azure_costs/policies.py`)

```python
from common.rbac_abac.registry import register_policy
import logging

logger = logging.getLogger(__name__)

@register_policy('view_all_costs')
def view_all_costs_policy(user_attrs, obj=None, action=None):
    """Policy to check if user can view all costs."""
    roles = user_attrs.get('roles', [])
    return 'costs_admin' in roles

@register_policy('view_subscription_costs')
def view_subscription_costs_policy(user_attrs, obj=None, action=None):
    """Policy to check if user can view costs for their subscriptions."""
    roles = user_attrs.get('roles', [])
    user_subscriptions = user_attrs.get('azure_subscription_ids', [])
    
    # Admins can view all
    if 'costs_admin' in roles:
        return True
    
    # Managers and viewers can view their assigned subscriptions
    if 'costs_manager' in roles or 'costs_viewer' in roles:
        if obj and hasattr(obj, 'subscription_id'):
            return obj.subscription_id in user_subscriptions
        return bool(user_subscriptions)
    
    return False

@register_policy('manage_budgets')
def manage_budgets_policy(user_attrs, obj=None, action=None):
    """Policy to check if user can manage budgets."""
    roles = user_attrs.get('roles', [])
    budget_limit = user_attrs.get('budget_limit', 0)
    
    # Only managers and admins can manage budgets
    if 'costs_admin' in roles:
        return True
    
    if 'costs_manager' in roles:
        if obj and hasattr(obj, 'amount'):
            return obj.amount <= budget_limit
        return budget_limit > 0
    
    return False

@register_policy('export_reports')
def export_reports_policy(user_attrs, obj=None, action=None):
    """Policy to check if user can export reports."""
    can_export = user_attrs.get('can_export_reports', False)
    roles = user_attrs.get('roles', [])
    
    # Admins always can export
    if 'costs_admin' in roles:
        return True
    
    # Others need explicit permission
    return can_export

@register_policy('view_cost_center')
def view_cost_center_policy(user_attrs, obj=None, action=None):
    """Policy to check if user can view specific cost center."""
    roles = user_attrs.get('roles', [])
    user_cost_centers = user_attrs.get('cost_center_ids', [])
    
    # Admins can view all
    if 'costs_admin' in roles:
        return True
    
    # Others can only view assigned cost centers
    if obj and hasattr(obj, 'cost_center_id'):
        return obj.cost_center_id in user_cost_centers
    
    return bool(user_cost_centers)
```

### 4. Update Django Settings

Add to `main/settings.py`:

```python
# Update INSTALLED_APPS to use the new app config
INSTALLED_APPS = [
    # ... other apps ...
    "azure_costs.apps.AzureCostsConfig",  # Instead of just "azure_costs"
    # ... other apps ...
]

# Ensure SERVICE_NAME is set correctly
SERVICE_NAME = 'azure_costs'  # Must match the service name in manifest
```

### 5. Create Models with ABAC Integration (Future)

When implementing actual Azure cost models:

```python
from django.db import models
from common.rbac_abac.mixins import ABACModelMixin
from common.rbac_abac.querysets import ABACManager

class AzureCostReport(ABACModelMixin, models.Model):
    subscription_id = models.CharField(max_length=100)
    cost_center_id = models.CharField(max_length=100)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    date = models.DateField()
    
    ABAC_POLICIES = {
        'view': 'view_subscription_costs',
        'edit': 'manage_budgets',
        'delete': 'costs_admin',  # Only admins can delete
        'export': 'export_reports'
    }
    
    objects = ABACManager()
    
    class Meta:
        db_table = 'azure_cost_reports'
```

### 6. Update Views to Use RBAC/ABAC

```python
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from common.rbac_abac.permissions import ABACPermission, RoleRequired
from common.rbac_abac.utils import get_user_attributes

@api_view(['GET'])
@permission_classes([IsAuthenticated])  # This will now work with RBAC
def private(request):
    # User attributes are automatically loaded by middleware
    user_attrs = getattr(request, 'user_attrs', {})
    
    return Response({
        "message": "This is a private endpoint",
        "user": {
            "id": request.user.id,
            "username": request.user.username,
            "email": getattr(request.user, 'email', None)
        },
        "roles": user_attrs.get('roles', []),
        "timestamp": timezone.now().isoformat()
    })

@api_view(['GET'])
@permission_classes([RoleRequired('costs_viewer', 'costs_manager', 'costs_admin')])
def view_costs(request):
    # Only users with cost viewing roles can access
    return Response({"costs": []})

@api_view(['POST'])
@permission_classes([RoleRequired('costs_manager', 'costs_admin')])
def create_budget(request):
    # Only managers and admins can create budgets
    return Response({"budget": "created"})
```

## Testing Strategy

After implementation:

1. **Service Registration Test**
   - Check logs for successful manifest registration
   - Verify service appears in identity provider admin

2. **Authentication Test**
   - Login via identity provider
   - Access `/api/private` with JWT token
   - Should return 200 with user info

3. **RBAC Test**
   - Create test users with different roles
   - Test role-based access to endpoints
   - Verify correct 403 responses for unauthorized roles

4. **ABAC Test**
   - Assign attributes to test users
   - Test policy-based access
   - Verify filtering works correctly

## Migration Path

1. **Phase 1**: Basic Integration (Required for tests to pass)
   - Create manifest.py
   - Update apps.py
   - Create basic policies.py
   - Update settings.py

2. **Phase 2**: Full Implementation
   - Create Azure cost models with ABAC
   - Implement cost tracking endpoints
   - Add complex policies
   - Integrate with Azure Cost Management API

3. **Phase 3**: Advanced Features
   - Implement budget alerts
   - Add cost optimization recommendations
   - Create reporting endpoints
   - Add export functionality

## Expected Outcomes

Once implemented:
- ✅ JWT authentication will work correctly
- ✅ User attributes will be loaded from Redis/identity provider
- ✅ Role-based access control will function
- ✅ All Playwright tests will pass
- ✅ Service will be fully integrated with RBAC/ABAC system

## Summary

The Azure Costs service requires proper RBAC/ABAC integration to function correctly with the VF Services authentication system. The main missing components are:

1. Service manifest registration
2. App configuration for auto-registration
3. ABAC policies definition
4. Proper app configuration in Django settings

These implementations will resolve the current 403 Forbidden errors and enable proper authentication and authorization for the service.